import os
from typing import List, Dict, Any
import logging
import pandas as pd
import pyarrow as pa
import pyarrow.parquet as pq
from pathlib import Path

optimization_suggestions_correlation = {
    "非root用户进程数": "1. 使用`ulimit`命令限制用户的最大进程数。2. 检查是否有异常进程（如僵尸进程），使用`ps aux`和`kill`命令清理。3. 优化应用程序，减少不必要的进程创建。",
    "活动进程数": "1. 检查是否有不必要的后台进程，使用`ps aux`和`kill`命令终止。2. 优化应用程序逻辑，减少并发进程数。3. 使用进程池（如Python的`multiprocessing.Pool`）限制并发进程数。",
    "当前运行队列等待运行的进程数": "1. 增加CPU资源（如升级CPU或增加CPU核心数）。2. 优化任务调度，使用优先级调度（如`nice`命令）确保关键任务优先执行。3. 减少不必要的任务并发，避免任务堆积。",
    "处在非中断睡眠状态的进程数": "1. 检查是否有进程因I/O操作阻塞，优化I/O性能（如使用SSD、增加磁盘带宽）。2. 优化数据库查询，减少锁等待时间。3. 检查是否有死锁或资源竞争问题，使用工具（如`strace`）分析进程状态。",
    "CPU利用率": "1. 优化代码逻辑，减少CPU密集型操作（如循环嵌套、复杂计算）。2. 使用多线程或多进程分担CPU负载。3. 升级CPU或增加CPU核心数。",
    "内存利用率": "1. 优化应用程序，减少内存泄漏（如使用内存分析工具`Valgrind`）。2. 增加物理内存或使用交换区（Swap）。3. 减少不必要的缓存，释放未使用的内存。",
    "1分钟平均负载": "1. 检查是否有高负载进程，使用`top`或`htop`命令定位并优化。2. 增加服务器资源（如CPU、内存）。3. 优化任务调度，避免短时间内大量任务并发。",
    "CPU平均等待IO率": "1. 优化磁盘I/O性能（如使用SSD、增加磁盘带宽）。2. 减少不必要的I/O操作（如批量读写数据）。3. 使用缓存（如Redis）减少对磁盘的依赖。",
    "中央处理器平均系统调用率": "1. 优化应用程序，减少频繁的系统调用（如合并小文件读写操作）。2. 使用更高效的系统调用（如`sendfile`替代`read/write`）。3. 检查是否有异常的系统调用（如频繁的文件打开/关闭），使用`strace`工具分析。",
    "交换区利用率": "1. 增加物理内存，减少对交换区的依赖。2. 优化应用程序，减少内存使用（如释放未使用的内存）。3. 调整交换区配置（如`swappiness`参数），减少交换区使用频率。",
    "等待连接数": "1. 优化服务器配置（如增加`backlog`参数）。2. 增加服务器资源（如CPU、内存）以处理更多连接。3. 使用负载均衡（如Nginx）分散连接压力。",
    "关闭连接数": "1. 检查是否有连接泄漏，使用工具（如`netstat`）分析连接状态。2. 优化应用程序，及时关闭不再使用的连接。3. 调整连接超时时间（如`keepalive_timeout`）。",
    "文件系统总利用率": "1. 清理不必要的文件（如日志文件、临时文件）。2. 增加磁盘容量或使用分布式文件系统（如HDFS）。3. 优化文件存储（如压缩文件、使用更高效的文件系统）。"
}

optimization_suggestions_random_forest = {
    "非root用户进程数": "1. 使用`ulimit`命令限制用户的最大进程数。2. 检查是否有异常进程（如僵尸进程），使用`ps aux`和`kill`命令清理。3. 优化应用程序，减少不必要的进程创建。4. 使用容器化技术（如Docker）限制每个容器的进程数。",
    "活动进程数": "1. 检查是否有不必要的后台进程，使用`ps aux`和`kill`命令终止。2. 优化应用程序逻辑，减少并发进程数。3. 使用进程池（如Python的`multiprocessing.Pool`）限制并发进程数。4. 使用任务队列（如Celery）管理异步任务。",
    "当前运行队列等待运行的进程数": "1. 增加CPU资源（如升级CPU或增加CPU核心数）。2. 优化任务调度，使用优先级调度（如`nice`命令）确保关键任务优先执行。3. 减少不必要的任务并发，避免任务堆积。4. 使用分布式任务调度系统（如Kubernetes）分散任务负载。",
    "处在非中断睡眠状态的进程数": "1. 检查是否有进程因I/O操作阻塞，优化I/O性能（如使用SSD、增加磁盘带宽）。2. 优化数据库查询，减少锁等待时间。3. 检查是否有死锁或资源竞争问题，使用工具（如`strace`）分析进程状态。4. 使用异步I/O（如AIO）减少阻塞。",
    "CPU利用率": "1. 优化代码逻辑，减少CPU密集型操作（如循环嵌套、复杂计算）。2. 使用多线程或多进程分担CPU负载。3. 升级CPU或增加CPU核心数。4. 使用JIT编译器（如PyPy）优化代码执行效率。",
    "内存利用率": "1. 优化应用程序，减少内存泄漏（如使用内存分析工具`Valgrind`）。2. 增加物理内存或使用交换区（Swap）。3. 减少不必要的缓存，释放未使用的内存。4. 使用内存池技术（如jemalloc）优化内存分配。",
    "1分钟平均负载": "1. 检查是否有高负载进程，使用`top`或`htop`命令定位并优化。2. 增加服务器资源（如CPU、内存）。3. 优化任务调度，避免短时间内大量任务并发。4. 使用自动扩展机制（如AWS Auto Scaling）动态调整资源。",
    "CPU平均等待IO率": "1. 优化磁盘I/O性能（如使用SSD、增加磁盘带宽）。2. 减少不必要的I/O操作（如批量读写数据）。3. 使用缓存（如Redis）减少对磁盘的依赖。4. 使用异步I/O模型（如Node.js）提高I/O效率。",
    "中央处理器平均系统调用率": "1. 优化应用程序，减少频繁的系统调用（如合并小文件读写操作）。2. 使用更高效的系统调用（如`sendfile`替代`read/write`）。3. 检查是否有异常的系统调用（如频繁的文件打开/关闭），使用`strace`工具分析。4. 使用用户态网络栈（如DPDK）减少内核态系统调用。",
    "交换区利用率": "1. 增加物理内存，减少对交换区的依赖。2. 优化应用程序，减少内存使用（如释放未使用的内存）。3. 调整交换区配置（如`swappiness`参数），减少交换区使用频率。4. 使用内存压缩技术（如Zswap）减少交换区压力。",
    "等待连接数": "1. 优化服务器配置（如增加`backlog`参数）。2. 增加服务器资源（如CPU、内存）以处理更多连接。3. 使用负载均衡（如Nginx）分散连接压力。4. 使用连接池技术（如HikariCP）管理数据库连接。",
    "关闭连接数": "1. 检查是否有连接泄漏，使用工具（如`netstat`）分析连接状态。2. 优化应用程序，及时关闭不再使用的连接。3. 调整连接超时时间（如`keepalive_timeout`）。4. 使用长连接复用技术（如HTTP/2）减少连接开销。",
    "文件系统总利用率": "1. 清理不必要的文件（如日志文件、临时文件）。2. 增加磁盘容量或使用分布式文件系统（如HDFS）。3. 优化文件存储（如压缩文件、使用更高效的文件系统）。4. 使用对象存储（如S3）替代本地文件系统。"
}


def safe_format(value):
    # 如果值是 NaN 或 None，则返回 0 或其他默认值
    if pd.isna(value):
        return None  # 或者根据需求返回 None
    return "{:.6f}".format(value)


def get_bottleneck_analysis(url):
    """根据URL特征返回字符串格式的分析"""
    # 增强版规则库
    analysis_rules = [
        {
            'keywords': ['account', 'act'],
            'cause': "高频账户操作导致数据库锁竞争",
            'solution': "优化账户表索引（添加复合索引）；引入Redis缓存账户状态信息；批量处理账户操作"  # 改为字符串
        },
        {
            'keywords': ['cust', 'customer'],
            'cause': "客户信息关联查询复杂度过高",
            'solution': "物化视图预计算关联数据；引入Elasticsearch优化查询；业务拆分降低事务粒度"
        },
        {
            'keywords': ['insert', 'create'],
            'cause': "逐条写入导致IO压力过大",
            'solution': "批量操作合并数据库事务；采用异步队列缓冲写入；调整存储引擎配置"
        },
        {
            'keywords': ['file', 'upload'],
            'cause': "大文件传输引发网络瓶颈",
            'solution': "实现分块上传/断点续传；使用OSS对象存储分流；启用Brotli压缩传输"
        }
    ]

    # 带优先级的匹配逻辑
    for rule in analysis_rules:
        if any(kw in url.lower() for kw in rule['keywords']):
            return rule

    # 默认返回（也保持字符串格式）
    return {
        'cause': "业务逻辑处理耗时过长",
        'solution': "使用性能剖析工具定位热点；优化算法时间复杂度；考虑JIT编译优化"
    }
